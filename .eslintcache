[{"C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\index.js":"1","C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\App.js":"2","C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\components\\Search.js":"3","C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\components\\List.js":"4","C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\components\\Breadcrumb.js":"5","C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\store\\store.js":"6","C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\store\\reducers.js":"7","C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\store\\actions.js":"8","C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\store\\types.js":"9","C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\components\\AtomControl.js":"10","C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\components\\Atom.js":"11","C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\components\\Textarea.js":"12","C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\helperFunctions.js":"13"},{"size":220,"mtime":1609834179017,"results":"14","hashOfConfig":"15"},{"size":1138,"mtime":1610189657286,"results":"16","hashOfConfig":"15"},{"size":234,"mtime":1610099831659,"results":"17","hashOfConfig":"15"},{"size":1150,"mtime":1610614615262,"results":"18","hashOfConfig":"15"},{"size":150,"mtime":1610099825266,"results":"19","hashOfConfig":"15"},{"size":817,"mtime":1610199913243,"results":"20","hashOfConfig":"15"},{"size":6307,"mtime":1610614432553,"results":"21","hashOfConfig":"15"},{"size":7341,"mtime":1610615061737,"results":"22","hashOfConfig":"15"},{"size":1020,"mtime":1610475754834,"results":"23","hashOfConfig":"15"},{"size":443,"mtime":1610614968243,"results":"24","hashOfConfig":"15"},{"size":2437,"mtime":1610613950239,"results":"25","hashOfConfig":"15"},{"size":852,"mtime":1610452497497,"results":"26","hashOfConfig":"15"},{"size":2973,"mtime":1610614500131,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"al3i9i",{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"30"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44","usedDeprecatedRules":"30"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"51","messages":"52","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"30"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"30"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"30"},"C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\index.js",[],["60","61"],"C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\App.js",[],"C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\components\\Search.js",[],"C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\components\\List.js",["62"],"import React from 'react'\r\nimport {useEffect} from 'react'\r\nimport {fetchData, noEmptyList} from '../store/actions'\r\nimport { useDispatch,  useSelector } from 'react-redux'\r\nimport Atom from './Atom'\r\n\r\nexport default function List() {\r\n\r\n    const dispatch = useDispatch()\r\n    const listState = useSelector(state => state.list);\r\n\r\n    useEffect(() => {\r\n        dispatch(fetchData())\r\n        // dispatch(fetchData)\r\n        // return () => {\r\n        //   cleanup\r\n        // }\r\n      }, [])\r\n    \r\n    if (listState.length === 0) {\r\n        noEmptyList()\r\n    }\r\n    \r\n\treturn (\r\n\t\t<>\r\n          \t<div >\r\n\t\t\t\t{listState.loadingData ? <h1> Loading data </h1> :\r\n                listState.listContent ? \r\n\t\t\t\t\t<ul className=\"listContainer\">\r\n\t\t\t\t\t\t{listState.listContent.map((atom) => {\r\n\t\t\t\t\t\t\tif(atom.hidden === false){\r\n\t\t\t\t\t\t\t\treturn(\r\n\t\t\t\t\t\t\t\t\t<li >\r\n\t\t\t\t\t\t\t\t\t\t<Atom\r\n\t\t\t\t\t\t\t\t\t\t\tatom={atom}\r\n\t\t\t\t\t\t\t\t\t\t\tdispatch={dispatch}\r\n\t\t\t\t\t\t\t\t\t\t\t>\r\n\t\t\t\t\t\t\t\t\t\t</Atom> \r\n\t\t\t\t\t\t\t\t\t</li>\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t}else{\r\n\t\t\t\t\t\t\t\treturn null\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})}\r\n\t\t\t\t\t</ul> :\r\n                null\r\n            \t}\r\n\r\n            </div> \r\n        </>\r\n    )\r\n}\r\n\r\n","C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\components\\Breadcrumb.js",[],"C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\store\\store.js",[],"C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\store\\reducers.js",["63"],"import * as types from './types'\r\n\r\nexport const listReducer = (state={}, action) => {\r\n    switch(action.type){\r\n        case types.FETCH_DATA:\r\n            return { ...state, loadingData: true }\r\n\r\n        case types.FETCHING_DATA_SUCCES:\r\n            return { ...state, \r\n                    listName: action.payload.listName,\r\n                    listContent: action.payload.listContent,\r\n                    loadingData: false }\r\n\r\n        case types.FETCHING_DATA_FAILED:\r\n            return { ...state, \r\n                    loadingData: false, \r\n                    errorMessage: action.payload }\r\n\r\n        case types.FOCUS_ATOM:\r\n            return { ...state,\r\n                    focussedAtomId: action.payload.focussedAtomId,\r\n                    focussedField: action.payload.focussedField }\r\n\r\n        case types.BLUR_ATOM:\r\n            if (state.focussedAtomId === action.payload.focussedAtomId &&\r\n                state.focussedField === action.payload.focussedField){\r\n                // in case that another focus action is dispatched before\r\n                // this blur action, it's nessecary to check that the right\r\n                // atom is blurred\r\n                return { ...state,\r\n                    focussedAtomId: \"\",\r\n                    focussedField: \"\" }\r\n            } else {\r\n                // the case when focus action is dispatched before a blur action\r\n                // no action needed, focus action has overwritten the old state\r\n                return { ...state }\r\n            }\r\n\r\n        case types.EDIT_ATOM_TITLE:\r\n            let editedTitle = state.listContent.map(atom => {\r\n                if (atom.id === action.payload.atomId){    \r\n                    return { ...atom, title: action.payload.title}\r\n                } else {\r\n                    return atom\r\n                }\r\n            })  \r\n            return{ ...state,\r\n                listContent: editedTitle\r\n            }\r\n\r\n        case types.EDIT_ATOM_NOTES:\r\n            let editedNotes = state.listContent.map(atom => {\r\n                if (atom.id === action.payload.atomId){    \r\n                    return { ...atom, notes: action.payload.notes}\r\n                } else {\r\n                    return atom\r\n                }\r\n            })  \r\n            return{ ...state,\r\n                listContent: editedNotes\r\n            }\r\n\r\n        case types.TOGGLE_ATOM_COMPLETE:\r\n            return { ...state, listContent: state.listContent.map(atom => {\r\n                if (atom.id=== action.payload){\r\n                        let completed = atom.completed? false : true \r\n                    return {...atom, completed: completed}\r\n                }else{\r\n                    return atom\r\n                }\r\n            })}\r\n\r\n        case types.MARK_SUBTREE_COMPLETE:\r\n            console.log(\"payload:\", action.payload)\r\n            return { ...state, listContent: state.listContent.map((atom, index) => {\r\n                if(index >= action.payload.startIndex && index <= action.payload.stopIndex){\r\n                    return { ...atom, completed: true}\r\n                } else{\r\n                    return { ...atom }\r\n                }\r\n            })}\r\n\r\n        case types.MARK_SUBTREE_UNCOMPLETE:\r\n            console.log(\"payload:\", action.payload)\r\n            return { ...state, listContent: state.listContent.map((atom, index) => {\r\n                if(index >= action.payload.startIndex && index <= action.payload.stopIndex){\r\n                    return { ...atom, completed: false}\r\n                } else{\r\n                    return { ...atom }\r\n                }\r\n            })}\r\n\r\n        case types.INDENT_SUBTREE:\r\n            return { ...state, listContent: state.listContent.map((atom, index) => {\r\n                if(index >= action.payload.startIndex && index <= action.payload.stopIndex){\r\n                    return { ...atom, indent: atom.indent + 1}\r\n                } else{\r\n                    return { ...atom }\r\n                }\r\n            })}\r\n\r\n        case types.UNINDENT_SUBTREE:\r\n            return { ...state, listContent: state.listContent.map((atom, index) => {\r\n                if(index >= action.payload.startIndex && index <= action.payload.stopIndex){\r\n                    return { ...atom, indent: atom.indent - 1}\r\n                } else{\r\n                    return { ...atom }\r\n                }\r\n            })}\r\n\r\n        case types.MARK_CHILDREN_HIDDEN:\r\n            return { ...state, listContent: state.listContent.map((atom, index) => {\r\n                if(index >= action.payload.startIndex && index <= action.payload.stopIndex){\r\n                    return { ...atom, hidden: true}\r\n                } else{\r\n                    return { ...atom }\r\n                }\r\n            })}\r\n\r\n        case types.MARK_CHILDREN_VISIBLE:\r\n            return { ...state, listContent: state.listContent.map((atom, index) => {\r\n                if(index >= action.payload.startIndex && index <= action.payload.stopIndex){\r\n                    return { ...atom, hidden: false}\r\n                } else{\r\n                    return { ...atom }\r\n                }\r\n            })}\r\n\r\n        case types.ADD_ATOM:\r\n            let slice = state.listContent.slice()\r\n            action.payload.index >= state.listContent.length ? \r\n                slice.push(action.payload.newAtom) :\r\n                slice.splice(action.payload.index, 0, action.payload.newAtom)\r\n            return { ...state, listContent: slice}\r\n\r\n        case types.DELETE_ATOM:\r\n            return { ...state, listContent: state.listContent.filter(atom => atom.id !== action.payload && atom)}\r\n        \r\n        case types.DELETE_SUBTREE:\r\n            return { ...state, listContent: state.listContent.filter(atom => {\r\n                if (!action.payload || atom.id !== action.payload[0]){\r\n                    return atom\r\n                } else {\r\n                    action.payload.shift()\r\n                }\r\n            })}\r\n\r\n        case types.NO_EMPTY_LIST:\r\n            let newlistconent = []\r\n            newlistconent.push(action.payload)\r\n            return { ...state, listContent: newlistconent}\r\n\r\n        case types.REORDER_LIST:\r\n            return { ...state, listContent: action.payload}\r\n\r\n        default:\r\n            return state\r\n    }\r\n}\r\n","C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\store\\actions.js",[],"C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\store\\types.js",[],"C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\components\\AtomControl.js",["64","65","66","67","68","69","70","71"],"C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\components\\Atom.js",["72"],"import React, {useState, useCallback} from 'react'\r\nimport {editAtomContent} from '../store/actions'\r\n// import TextareaAutosize from 'react-textarea-autosize'\r\nimport AtomControl from './AtomControl'\r\nimport Textarea from './Textarea'\r\nimport {debounce} from 'lodash'\r\n\r\nconst Atom = props => {\r\n    // impl local State for title and Notes\r\n    const [title, setTitle] = useState(props.atom.title)\r\n    const [notes, setNotes] = useState(props.atom.notes)\r\n\r\n    const debouncedEdit = useCallback(\r\n\t\tdebounce((nextValue, name, setContent) => {\r\n            props.dispatch(editAtomContent(props.atom.id, nextValue, name, setContent))\r\n        }, 200),\r\n\t\t[], \r\n\t)\r\n\r\n    const handleChange = (event, setContent) => {\r\n        // This function handles the local state and calls the debounced action.\r\n        // TThis enables fast front end change and low impact on expensive API calls.\r\n        const nextValue = event.target.value\r\n        const name = event.target.name\r\n        setContent(nextValue)\r\n\t\t// Even though handleChange is created on each render and executed\r\n        // it references the same debouncedSave that was created initially.\r\n        // The setContent function is used as a parameter in case some \r\n        // API call fails and the value needs to be reset stay in sync with\r\n        // backend data.\r\n\t\tdebouncedEdit(nextValue, name, setContent)\r\n    }\r\n\r\n    const createTextAreaComponent = (name, value, setContent) => {\r\n        const textAreaProps = { \r\n            dispatch:props.dispatch,\r\n            atomId:props.atom.id,\r\n            handleChange:handleChange,\r\n            completed: props.atom.completed? \"completed\" :  \"\"\r\n        }\r\n        return(\r\n            <Textarea\r\n                    name={name}\r\n                    value={value}\r\n                    setContent={setContent}\r\n                    { ...textAreaProps }\r\n            ></Textarea>\r\n        )\r\n    }\r\n\r\n    return (\r\n        <div className={\"atomContainer\"} style={{marginLeft:props.atom.indent*35 + 15/(1+props.atom.indent)}}>\r\n            <AtomControl atomId={props.atom.id} dispatch={props.dispatch}  />\r\n            \r\n            <div className=\"atomContentContainer\">\r\n                {createTextAreaComponent(\"title\", title, setTitle)}\r\n\r\n                {props.atom.notes ? createTextAreaComponent(\"notes\", notes, setNotes) : null}\r\n            </div>\r\n         </div>\r\n    )\r\n}\r\n\r\n\r\n\r\nexport default React.memo(Atom)\r\n","C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\components\\Textarea.js",["73"],"import React from 'react'\r\n\r\nimport {focusAtom, blurAtom, editAtomContent} from '../store/actions'\r\nimport TextareaAutosize from 'react-textarea-autosize'\r\n\r\nconst Textarea = (props) => {\r\n    return (\r\n        <TextareaAutosize\r\n                    name={props.name}\r\n                    className={`textarea textarea-${props.name} ${props.completed}`}\r\n                    value={props.value}\r\n                    minRows={1}\r\n                    spellCheck=\"false\"\r\n                    onFocus={e =>  props.dispatch(focusAtom(props.atomId, e.target.name))}\r\n                    onBlur={e => props.dispatch(blurAtom(props.atomId, e.target.name))}\r\n                    onChange={ e => props.handleChange(e, props.setContent) }\r\n                    \r\n                    // ref={ref}\r\n        ></TextareaAutosize>\r\n    )\r\n}\r\n\r\nexport default Textarea\r\n","C:\\Users\\Miguel\\Documents\\Projects\\JavaScript\\nuclei\\src\\helperFunctions.js",["74","75"],"export const getSubTree = (list, atomId) => {\r\n    // let atomd = null\r\n    let startIndex = null\r\n    let refIndent = null\r\n    let start = false\r\n    let skip = false\r\n    let subtree = list.slice().filter((atom, index) => {\r\n        if(skip === false){\r\n            if(atom.id === atomId){\r\n                startIndex = index\r\n                refIndent = atom.indent\r\n                start = true\r\n                return atom\r\n            } else if ( start === true && skip === false){\r\n                if (atom.indent > refIndent) {\r\n                    return atom\r\n                } else {\r\n                    skip = true\r\n                }\r\n            } \r\n        }\r\n    })\r\n\r\n    const stopIndex = startIndex + subtree.length - 1\r\n    return {subtree, startIndex, stopIndex} \r\n}\r\n\r\n// export const getSubTreeRange = (list, atomId) => {\r\n//     const {subtree, refIndex} = getSubTree(list, atomId)\r\n//     const startIndex = refIndex\r\n//     const stopIndex = startIndex + subtree.length - 1\r\n//     return {startIndex, stopIndex}\r\n// }\r\n\r\nconst indentAtom = (atom) => {\r\n    return { ...atom, indent: atom.indent + 1}\r\n}\r\n\r\nconst indentTree = (list) => {\r\n    return list.map(atom => indentAtom(atom))\r\n}\r\n\r\nexport const tryIndent = (list, atomId) => {\r\n    const {subtree, startIndex, stopIndex} = getSubTree(list, atomId)\r\n    if(startIndex === 0 ){\r\n        // first atom cannot be indented\r\n        return {canIndent: false, payload: null}\r\n    } else if (list[startIndex-1].indent < subtree[0].indent){\r\n        // cannot indent atom if it's a child of previous atom\r\n        return {canIndent: false, payload: null}\r\n    } else {\r\n        return {canIndent: true, payload: {startIndex, stopIndex}}\r\n    }\r\n}\r\n\r\nexport const tryUnindent = (list, atomId) => {\r\n    const {subtree, startIndex, stopIndex} = getSubTree(list, atomId)\r\n    if(subtree[0].indent === 0 ){\r\n        // 0 indent is minimum\r\n        return {canUnindent: false, payload: null}\r\n    } else {\r\n        return {canUnindent: true, payload: {startIndex, stopIndex}}\r\n    }\r\n}\r\n\r\nexport const newAtom = (list, refAtomId, atomParams) => {\r\n    const {subtree, startIndex} = getSubTree(list, refAtomId)\r\n    const hasChildren = subtree.length === 1 ? false : true\r\n\r\n    \r\n    if(hasChildren){\r\n        // if ref atom has children, insert as first child\r\n        return {\r\n            index: startIndex + 1,\r\n            newAtom: createAtom({ ...atomParams, indent: subtree[0].indent + 1})\r\n        }\r\n    } else {\r\n        // else insert new atom as sibling\r\n        return {\r\n            index: startIndex + 1,\r\n            newAtom: createAtom({ ...atomParams, indent: subtree[0].indent})\r\n        }\r\n    }\r\n}\r\n\r\nexport const createAtom = (atomParams) => {\r\n    if(atomParams){\r\n        return { ...NEW_ATOM_TEMPLATE, ...atomParams}\r\n    } else {\r\n        return NEW_ATOM_TEMPLATE\r\n    }\r\n}\r\n\r\nconst NEW_ATOM_TEMPLATE = {\r\n    title: \"\",\r\n    notes: \"\",\r\n    indent: 0,\r\n    hidden: false,\r\n}",{"ruleId":"76","replacedBy":"77"},{"ruleId":"78","replacedBy":"79"},{"ruleId":"80","severity":1,"message":"81","line":18,"column":10,"nodeType":"82","endLine":18,"endColumn":12,"suggestions":"83"},{"ruleId":"84","severity":1,"message":"85","line":140,"column":75,"nodeType":"86","messageId":"87","endLine":140,"endColumn":77},{"ruleId":"88","severity":1,"message":"89","line":2,"column":9,"nodeType":"90","messageId":"91","endLine":2,"endColumn":28},{"ruleId":"88","severity":1,"message":"92","line":2,"column":30,"nodeType":"90","messageId":"91","endLine":2,"endColumn":40},{"ruleId":"88","severity":1,"message":"93","line":2,"column":42,"nodeType":"90","messageId":"91","endLine":2,"endColumn":49},{"ruleId":"88","severity":1,"message":"94","line":2,"column":51,"nodeType":"90","messageId":"91","endLine":2,"endColumn":72},{"ruleId":"88","severity":1,"message":"95","line":2,"column":74,"nodeType":"90","messageId":"91","endLine":2,"endColumn":87},{"ruleId":"88","severity":1,"message":"96","line":2,"column":89,"nodeType":"90","messageId":"91","endLine":2,"endColumn":104},{"ruleId":"88","severity":1,"message":"97","line":2,"column":106,"nodeType":"90","messageId":"91","endLine":2,"endColumn":118},{"ruleId":"88","severity":1,"message":"98","line":2,"column":120,"nodeType":"90","messageId":"91","endLine":2,"endColumn":134},{"ruleId":"80","severity":1,"message":"99","line":13,"column":27,"nodeType":"90","endLine":13,"endColumn":38},{"ruleId":"88","severity":1,"message":"100","line":3,"column":30,"nodeType":"90","messageId":"91","endLine":3,"endColumn":45},{"ruleId":"84","severity":1,"message":"85","line":7,"column":53,"nodeType":"86","messageId":"87","endLine":7,"endColumn":55},{"ruleId":"88","severity":1,"message":"101","line":39,"column":7,"nodeType":"90","messageId":"91","endLine":39,"endColumn":17},"no-native-reassign",["102"],"no-negated-in-lhs",["103"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'dispatch'. Either include it or remove the dependency array.","ArrayExpression",["104"],"array-callback-return","Array.prototype.filter() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd","no-unused-vars","'markSubtreeComplete' is defined but never used.","Identifier","unusedVar","'deleteAtom' is defined but never used.","'addAtom' is defined but never used.","'markSubtreeUncomplete' is defined but never used.","'indentSubtree' is defined but never used.","'unindentSubtree' is defined but never used.","'hideChildren' is defined but never used.","'unhideChildren' is defined but never used.","React Hook useCallback received a function whose dependencies are unknown. Pass an inline function instead.","'editAtomContent' is defined but never used.","'indentTree' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"105","fix":"106"},"Update the dependencies array to be: [dispatch]",{"range":"107","text":"108"},[492,494],"[dispatch]"]